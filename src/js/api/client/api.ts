/* tslint:disable */
/* eslint-disable */
/**
 * GNOME Extensions
 * extensions.gnome.org
 *
 * The version of the OpenAPI document: 1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BaseUserProfile
 */
export interface BaseUserProfile {
    /**
     * 
     * @type {number}
     * @memberof BaseUserProfile
     */
    'id': number;
    /**
     * Обязательное поле. Не более 150 символов. Только буквы, цифры и символы @/./+/-/_.
     * @type {string}
     * @memberof BaseUserProfile
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof BaseUserProfile
     */
    'avatar': string;
}
/**
 * 
 * @export
 * @interface ChangePassword
 */
export interface ChangePassword {
    /**
     * 
     * @type {string}
     * @memberof ChangePassword
     */
    'old_password': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePassword
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ChangePasswordRequest
 */
export interface ChangePasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    'old_password': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    'password_confirm': string;
}
/**
 * Default serializer used for user login. Please keep in mind that the authentication is done by separate function defined by :ref:`login-authenticator-setting` setting.  By default :ref:`login-authenticator-setting` function will use :ref:`user-login-fields-setting` setting to extract the login field from the validated serializer data either by using the \'login\' key (which is used here) or the specific login field name(s) (e.g. \'username\', \'email\').  If you want different behavior, you need to override :ref:`login-authenticator-setting` in your settings.
 * @export
 * @interface DefaultLogin
 */
export interface DefaultLogin {
    /**
     * 
     * @type {string}
     * @memberof DefaultLogin
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof DefaultLogin
     */
    'password': string;
}
/**
 * Default serializer used for user login. Please keep in mind that the authentication is done by separate function defined by :ref:`login-authenticator-setting` setting.  By default :ref:`login-authenticator-setting` function will use :ref:`user-login-fields-setting` setting to extract the login field from the validated serializer data either by using the \'login\' key (which is used here) or the specific login field name(s) (e.g. \'username\', \'email\').  If you want different behavior, you need to override :ref:`login-authenticator-setting` in your settings.
 * @export
 * @interface DefaultLoginRequest
 */
export interface DefaultLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultLoginRequest
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof DefaultLoginRequest
     */
    'password': string;
}
/**
 * Default serializer used for e-mail registration (e-mail change).
 * @export
 * @interface DefaultRegisterEmail
 */
export interface DefaultRegisterEmail {
    /**
     * 
     * @type {string}
     * @memberof DefaultRegisterEmail
     */
    'email': string;
}
/**
 * Default serializer used for e-mail registration (e-mail change).
 * @export
 * @interface DefaultRegisterEmailRequest
 */
export interface DefaultRegisterEmailRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultRegisterEmailRequest
     */
    'email': string;
}
/**
 * Default serializer used for sending reset password link.  It will use :ref:`send-reset-password-link-serializer-use-email-setting` setting.
 * @export
 * @interface DefaultSendResetPasswordLink
 */
export interface DefaultSendResetPasswordLink {
    /**
     * 
     * @type {string}
     * @memberof DefaultSendResetPasswordLink
     */
    'login': string;
}
/**
 * Default serializer used for sending reset password link.  It will use :ref:`send-reset-password-link-serializer-use-email-setting` setting.
 * @export
 * @interface DefaultSendResetPasswordLinkRequest
 */
export interface DefaultSendResetPasswordLinkRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultSendResetPasswordLinkRequest
     */
    'login': string;
}
/**
 * Default serializer used for user profile. It will use these:  * User fields * :ref:`user-hidden-fields-setting` setting * :ref:`user-public-fields-setting` setting * :ref:`user-editable-fields-setting` setting  to automagically generate the required serializer fields.
 * @export
 * @interface DefaultUserProfile
 */
export interface DefaultUserProfile {
    /**
     * 
     * @type {number}
     * @memberof DefaultUserProfile
     */
    'id': number;
    /**
     * Обязательное поле. Не более 150 символов. Только буквы, цифры и символы @/./+/-/_.
     * @type {string}
     * @memberof DefaultUserProfile
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof DefaultUserProfile
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof DefaultUserProfile
     */
    'display_name'?: string;
}
/**
 * Default serializer used for user profile. It will use these:  * User fields * :ref:`user-hidden-fields-setting` setting * :ref:`user-public-fields-setting` setting * :ref:`user-editable-fields-setting` setting  to automagically generate the required serializer fields.
 * @export
 * @interface DefaultUserProfileRequest
 */
export interface DefaultUserProfileRequest {
    /**
     * Обязательное поле. Не более 150 символов. Только буквы, цифры и символы @/./+/-/_.
     * @type {string}
     * @memberof DefaultUserProfileRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof DefaultUserProfileRequest
     */
    'display_name'?: string;
}
/**
 * 
 * @export
 * @interface Extension
 */
export interface Extension {
    /**
     * 
     * @type {number}
     * @memberof Extension
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    'name': string;
    /**
     * 
     * @type {ExtensionCreator}
     * @memberof Extension
     */
    'creator': ExtensionCreator;
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    'updated'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Extension
     */
    'downloads'?: number;
    /**
     * 
     * @type {number}
     * @memberof Extension
     */
    'popularity'?: number;
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    'screenshot'?: string;
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    'icon'?: string;
    /**
     * 
     * @type {number}
     * @memberof Extension
     */
    'rating'?: number;
    /**
     * 
     * @type {number}
     * @memberof Extension
     */
    'rated'?: number;
}
/**
 * 
 * @export
 * @interface ExtensionCreator
 */
export interface ExtensionCreator {
    /**
     * 
     * @type {number}
     * @memberof ExtensionCreator
     */
    'id': number;
    /**
     * Обязательное поле. Не более 150 символов. Только буквы, цифры и символы @/./+/-/_.
     * @type {string}
     * @memberof ExtensionCreator
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof ExtensionCreator
     */
    'avatar': string;
}
/**
 * 
 * @export
 * @interface ExtensionUpload
 */
export interface ExtensionUpload {
    /**
     * 
     * @type {string}
     * @memberof ExtensionUpload
     */
    'source': string;
    /**
     * 
     * @type {boolean}
     * @memberof ExtensionUpload
     */
    'shell_license_compliant': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExtensionUpload
     */
    'tos_compliant': boolean;
    /**
     * 
     * @type {LicenseEnum}
     * @memberof ExtensionUpload
     */
    'license': LicenseEnum;
}
/**
 * 
 * @export
 * @interface ExtensionVersion
 */
export interface ExtensionVersion {
    /**
     * 
     * @type {string}
     * @memberof ExtensionVersion
     */
    'extension': string;
    /**
     * 
     * @type {number}
     * @memberof ExtensionVersion
     */
    'version'?: number;
    /**
     * 
     * @type {StatusEnum}
     * @memberof ExtensionVersion
     */
    'status': StatusEnum;
    /**
     * 
     * @type {Array<ShellVersion>}
     * @memberof ExtensionVersion
     */
    'shell_versions': Array<ShellVersion>;
    /**
     * 
     * @type {string}
     * @memberof ExtensionVersion
     */
    'created': string;
}
/**
 * 
 * @export
 * @interface ExtensionsUpdatesRequest
 */
export interface ExtensionsUpdatesRequest {
    /**
     * 
     * @type {{ [key: string]: InstalledExtensionRequest; }}
     * @memberof ExtensionsUpdatesRequest
     */
    'installed': { [key: string]: InstalledExtensionRequest; };
    /**
     * 
     * @type {string}
     * @memberof ExtensionsUpdatesRequest
     */
    'shell_version': string;
    /**
     * 
     * @type {boolean}
     * @memberof ExtensionsUpdatesRequest
     */
    'version_validation_enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface InstalledExtensionRequest
 */
export interface InstalledExtensionRequest {
    /**
     * 
     * @type {string}
     * @memberof InstalledExtensionRequest
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const LicenseEnum = {
    Apache20: 'Apache-2.0',
    Bsd2Clause: 'BSD-2-Clause',
    Bsd3Clause: 'BSD-3-Clause',
    Epl20: 'EPL-2.0',
    Gpl20: 'GPL-2.0',
    Gpl20OrLater: 'GPL-2.0 or later',
    Gpl30: 'GPL-3.0',
    Gpl30OrLater: 'GPL-3.0-or-later',
    Mit: 'MIT',
    Mpl20: 'MPL-2.0'
} as const;

export type LicenseEnum = typeof LicenseEnum[keyof typeof LicenseEnum];


/**
 * 
 * @export
 * @interface Logout
 */
export interface Logout {
    /**
     * 
     * @type {boolean}
     * @memberof Logout
     */
    'revoke_token'?: boolean;
}
/**
 * 
 * @export
 * @interface LogoutRequest
 */
export interface LogoutRequest {
    /**
     * 
     * @type {boolean}
     * @memberof LogoutRequest
     */
    'revoke_token'?: boolean;
}
/**
 * 
 * @export
 * @interface PaginatedExtensionList
 */
export interface PaginatedExtensionList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedExtensionList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExtensionList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExtensionList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Extension>}
     * @memberof PaginatedExtensionList
     */
    'results'?: Array<Extension>;
}
/**
 * 
 * @export
 * @interface PaginatedExtensionVersionList
 */
export interface PaginatedExtensionVersionList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedExtensionVersionList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExtensionVersionList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExtensionVersionList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ExtensionVersion>}
     * @memberof PaginatedExtensionVersionList
     */
    'results'?: Array<ExtensionVersion>;
}
/**
 * Default serializer used for user profile. It will use these:  * User fields * :ref:`user-hidden-fields-setting` setting * :ref:`user-public-fields-setting` setting * :ref:`user-editable-fields-setting` setting  to automagically generate the required serializer fields.
 * @export
 * @interface PatchedDefaultUserProfileRequest
 */
export interface PatchedDefaultUserProfileRequest {
    /**
     * Обязательное поле. Не более 150 символов. Только буквы, цифры и символы @/./+/-/_.
     * @type {string}
     * @memberof PatchedDefaultUserProfileRequest
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedDefaultUserProfileRequest
     */
    'display_name'?: string;
}
/**
 * Default serializer used for user registration. It will use these:  * User fields * :ref:`user-hidden-fields-setting` setting * :ref:`user-public-fields-setting` setting  to automagically generate the required serializer fields.
 * @export
 * @interface RegisterUser
 */
export interface RegisterUser {
    /**
     * 
     * @type {number}
     * @memberof RegisterUser
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof RegisterUser
     */
    'password': string;
    /**
     * Обязательное поле. Не более 150 символов. Только буквы, цифры и символы @/./+/-/_.
     * @type {string}
     * @memberof RegisterUser
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterUser
     */
    'display_name'?: string;
}
/**
 * Default serializer used for user registration. It will use these:  * User fields * :ref:`user-hidden-fields-setting` setting * :ref:`user-public-fields-setting` setting  to automagically generate the required serializer fields.
 * @export
 * @interface RegisterUserRequest
 */
export interface RegisterUserRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'password': string;
    /**
     * Обязательное поле. Не более 150 символов. Только буквы, цифры и символы @/./+/-/_.
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'display_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'password_confirm': string;
}
/**
 * 
 * @export
 * @interface ResetPassword
 */
export interface ResetPassword {
    /**
     * 
     * @type {string}
     * @memberof ResetPassword
     */
    'user_id': string;
    /**
     * 
     * @type {number}
     * @memberof ResetPassword
     */
    'timestamp': number;
    /**
     * 
     * @type {string}
     * @memberof ResetPassword
     */
    'signature': string;
    /**
     * 
     * @type {string}
     * @memberof ResetPassword
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ResetPasswordRequest
 */
export interface ResetPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'user_id': string;
    /**
     * 
     * @type {number}
     * @memberof ResetPasswordRequest
     */
    'timestamp': number;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'signature': string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ShellVersion
 */
export interface ShellVersion {
    /**
     * 
     * @type {number}
     * @memberof ShellVersion
     */
    'major': number;
    /**
     * 
     * @type {number}
     * @memberof ShellVersion
     */
    'minor': number;
    /**
     * 
     * @type {number}
     * @memberof ShellVersion
     */
    'point': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const StatusEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type StatusEnum = typeof StatusEnum[keyof typeof StatusEnum];


/**
 * 
 * @export
 * @interface UserProfile
 */
export interface UserProfile {
    /**
     * 
     * @type {number}
     * @memberof UserProfile
     */
    'id': number;
    /**
     * Обязательное поле. Не более 150 символов. Только буквы, цифры и символы @/./+/-/_.
     * @type {string}
     * @memberof UserProfile
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'avatar': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof UserProfile
     */
    'extensions': Array<number>;
}
/**
 * 
 * @export
 * @interface VerifyEmail
 */
export interface VerifyEmail {
    /**
     * 
     * @type {string}
     * @memberof VerifyEmail
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof VerifyEmail
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof VerifyEmail
     */
    'timestamp': number;
    /**
     * 
     * @type {string}
     * @memberof VerifyEmail
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface VerifyEmailRequest
 */
export interface VerifyEmailRequest {
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailRequest
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailRequest
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof VerifyEmailRequest
     */
    'timestamp': number;
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailRequest
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface VerifyRegistration
 */
export interface VerifyRegistration {
    /**
     * 
     * @type {string}
     * @memberof VerifyRegistration
     */
    'user_id': string;
    /**
     * 
     * @type {number}
     * @memberof VerifyRegistration
     */
    'timestamp': number;
    /**
     * 
     * @type {string}
     * @memberof VerifyRegistration
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface VerifyRegistrationRequest
 */
export interface VerifyRegistrationRequest {
    /**
     * 
     * @type {string}
     * @memberof VerifyRegistrationRequest
     */
    'user_id': string;
    /**
     * 
     * @type {number}
     * @memberof VerifyRegistrationRequest
     */
    'timestamp': number;
    /**
     * 
     * @type {string}
     * @memberof VerifyRegistrationRequest
     */
    'signature': string;
}

/**
 * V1Api - axios parameter creator
 * @export
 */
export const V1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change the user password.
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsChangePasswordCreate: async (changePasswordRequest: ChangePasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordRequest' is not null or undefined
            assertParamExists('v1AccountsChangePasswordCreate', 'changePasswordRequest', changePasswordRequest)
            const localVarPath = `/api/v1/accounts/change-password/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logs in the user via given login and password.
         * @param {DefaultLoginRequest} defaultLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsLoginCreate: async (defaultLoginRequest: DefaultLoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'defaultLoginRequest' is not null or undefined
            assertParamExists('v1AccountsLoginCreate', 'defaultLoginRequest', defaultLoginRequest)
            const localVarPath = `/api/v1/accounts/login/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(defaultLoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logs out the user. returns an error if the user is not authenticated.
         * @param {LogoutRequest} [logoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsLogoutCreate: async (logoutRequest?: LogoutRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/accounts/logout/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logoutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get or set user profile.
         * @param {DefaultUserProfileRequest} defaultUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsProfileCreate: async (defaultUserProfileRequest: DefaultUserProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'defaultUserProfileRequest' is not null or undefined
            assertParamExists('v1AccountsProfileCreate', 'defaultUserProfileRequest', defaultUserProfileRequest)
            const localVarPath = `/api/v1/accounts/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(defaultUserProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get or set user profile.
         * @param {PatchedDefaultUserProfileRequest} [patchedDefaultUserProfileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsProfilePartialUpdate: async (patchedDefaultUserProfileRequest?: PatchedDefaultUserProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/accounts/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedDefaultUserProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get or set user profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsProfileRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/accounts/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get or set user profile.
         * @param {DefaultUserProfileRequest} defaultUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsProfileUpdate: async (defaultUserProfileRequest: DefaultUserProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'defaultUserProfileRequest' is not null or undefined
            assertParamExists('v1AccountsProfileUpdate', 'defaultUserProfileRequest', defaultUserProfileRequest)
            const localVarPath = `/api/v1/accounts/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(defaultUserProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register new user.
         * @param {RegisterUserRequest} registerUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsRegisterCreate: async (registerUserRequest: RegisterUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerUserRequest' is not null or undefined
            assertParamExists('v1AccountsRegisterCreate', 'registerUserRequest', registerUserRequest)
            const localVarPath = `/api/v1/accounts/register/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register new email.
         * @param {DefaultRegisterEmailRequest} defaultRegisterEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsRegisterEmailCreate: async (defaultRegisterEmailRequest: DefaultRegisterEmailRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'defaultRegisterEmailRequest' is not null or undefined
            assertParamExists('v1AccountsRegisterEmailCreate', 'defaultRegisterEmailRequest', defaultRegisterEmailRequest)
            const localVarPath = `/api/v1/accounts/register-email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(defaultRegisterEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset password, given the signature and timestamp from the link.
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsResetPasswordCreate: async (resetPasswordRequest: ResetPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordRequest' is not null or undefined
            assertParamExists('v1AccountsResetPasswordCreate', 'resetPasswordRequest', resetPasswordRequest)
            const localVarPath = `/api/v1/accounts/reset-password/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send email with reset password link.
         * @param {DefaultSendResetPasswordLinkRequest} defaultSendResetPasswordLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsSendResetPasswordLinkCreate: async (defaultSendResetPasswordLinkRequest: DefaultSendResetPasswordLinkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'defaultSendResetPasswordLinkRequest' is not null or undefined
            assertParamExists('v1AccountsSendResetPasswordLinkCreate', 'defaultSendResetPasswordLinkRequest', defaultSendResetPasswordLinkRequest)
            const localVarPath = `/api/v1/accounts/send-reset-password-link/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(defaultSendResetPasswordLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify email via signature.
         * @param {VerifyEmailRequest} verifyEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsVerifyEmailCreate: async (verifyEmailRequest: VerifyEmailRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyEmailRequest' is not null or undefined
            assertParamExists('v1AccountsVerifyEmailCreate', 'verifyEmailRequest', verifyEmailRequest)
            const localVarPath = `/api/v1/accounts/verify-email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify registration via signature.
         * @param {VerifyRegistrationRequest} verifyRegistrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsVerifyRegistrationCreate: async (verifyRegistrationRequest: VerifyRegistrationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyRegistrationRequest' is not null or undefined
            assertParamExists('v1AccountsVerifyRegistrationCreate', 'verifyRegistrationRequest', verifyRegistrationRequest)
            const localVarPath = `/api/v1/accounts/verify-registration/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyRegistrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} source 
         * @param {boolean} shellLicenseCompliant 
         * @param {boolean} tosCompliant 
         * @param {LicenseEnum} license 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExtensionsCreate: async (source: any, shellLicenseCompliant: boolean, tosCompliant: boolean, license: LicenseEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'source' is not null or undefined
            assertParamExists('v1ExtensionsCreate', 'source', source)
            // verify required parameter 'shellLicenseCompliant' is not null or undefined
            assertParamExists('v1ExtensionsCreate', 'shellLicenseCompliant', shellLicenseCompliant)
            // verify required parameter 'tosCompliant' is not null or undefined
            assertParamExists('v1ExtensionsCreate', 'tosCompliant', tosCompliant)
            // verify required parameter 'license' is not null or undefined
            assertParamExists('v1ExtensionsCreate', 'license', license)
            const localVarPath = `/api/v1/extensions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (source !== undefined) { 
                localVarFormParams.append('source', source as any);
            }
    
            if (shellLicenseCompliant !== undefined) { 
                localVarFormParams.append('shell_license_compliant', shellLicenseCompliant as any);
            }
    
            if (tosCompliant !== undefined) { 
                localVarFormParams.append('tos_compliant', tosCompliant as any);
            }
    
            if (license !== undefined) { 
                localVarFormParams.append('license', new Blob([JSON.stringify(license)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} [uuid] 
         * @param {0 | 1 | 2 | 3 | 4} [status] 
         * @param {boolean} [recommended] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExtensionsList: async (uuid?: Array<string>, status?: 0 | 1 | 2 | 3 | 4, recommended?: boolean, ordering?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/extensions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (uuid) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (recommended !== undefined) {
                localVarQueryParameter['recommended'] = recommended;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExtensionsRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('v1ExtensionsRetrieve', 'uuid', uuid)
            const localVarPath = `/api/v1/extensions/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} query 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {boolean} [recommended] 
         * @param {'asc' | 'desc'} [ordering] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExtensionsSearchRetrieve: async (query: string, page?: number, pageSize?: number, recommended?: boolean, ordering?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('v1ExtensionsSearchRetrieve', 'query', query)
            const localVarPath = `/api/v1/extensions/search/{query}/`
                .replace(`{${"query"}}`, encodeURIComponent(String(query)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (recommended !== undefined) {
                localVarQueryParameter['recommended'] = recommended;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ExtensionsUpdatesRequest} extensionsUpdatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExtensionsUpdatesCreate: async (extensionsUpdatesRequest: ExtensionsUpdatesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'extensionsUpdatesRequest' is not null or undefined
            assertParamExists('v1ExtensionsUpdatesCreate', 'extensionsUpdatesRequest', extensionsUpdatesRequest)
            const localVarPath = `/api/v1/extensions/updates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(extensionsUpdatesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} extensionUuid 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {'json' | 'zip'} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExtensionsVersionsList: async (extensionUuid: string, page?: number, pageSize?: number, format?: 'json' | 'zip', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'extensionUuid' is not null or undefined
            assertParamExists('v1ExtensionsVersionsList', 'extensionUuid', extensionUuid)
            const localVarPath = `/api/v1/extensions/{extension_uuid}/versions/`
                .replace(`{${"extension_uuid"}}`, encodeURIComponent(String(extensionUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} extensionUuid 
         * @param {string} version 
         * @param {'json' | 'zip'} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExtensionsVersionsRetrieve: async (extensionUuid: string, version: string, format?: 'json' | 'zip', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'extensionUuid' is not null or undefined
            assertParamExists('v1ExtensionsVersionsRetrieve', 'extensionUuid', extensionUuid)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('v1ExtensionsVersionsRetrieve', 'version', version)
            const localVarPath = `/api/v1/extensions/{extension_uuid}/versions/{version}/`
                .replace(`{${"extension_uuid"}}`, encodeURIComponent(String(extensionUuid)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1HelloRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/hello/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfileRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ProfileRetrieve', 'id', id)
            const localVarPath = `/api/v1/profile/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1Api - functional programming interface
 * @export
 */
export const V1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Change the user password.
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AccountsChangePasswordCreate(changePasswordRequest: ChangePasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangePassword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AccountsChangePasswordCreate(changePasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Logs in the user via given login and password.
         * @param {DefaultLoginRequest} defaultLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AccountsLoginCreate(defaultLoginRequest: DefaultLoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefaultLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AccountsLoginCreate(defaultLoginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Logs out the user. returns an error if the user is not authenticated.
         * @param {LogoutRequest} [logoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AccountsLogoutCreate(logoutRequest?: LogoutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Logout>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AccountsLogoutCreate(logoutRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get or set user profile.
         * @param {DefaultUserProfileRequest} defaultUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AccountsProfileCreate(defaultUserProfileRequest: DefaultUserProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefaultUserProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AccountsProfileCreate(defaultUserProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get or set user profile.
         * @param {PatchedDefaultUserProfileRequest} [patchedDefaultUserProfileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AccountsProfilePartialUpdate(patchedDefaultUserProfileRequest?: PatchedDefaultUserProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefaultUserProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AccountsProfilePartialUpdate(patchedDefaultUserProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get or set user profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AccountsProfileRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefaultUserProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AccountsProfileRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get or set user profile.
         * @param {DefaultUserProfileRequest} defaultUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AccountsProfileUpdate(defaultUserProfileRequest: DefaultUserProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefaultUserProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AccountsProfileUpdate(defaultUserProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register new user.
         * @param {RegisterUserRequest} registerUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AccountsRegisterCreate(registerUserRequest: RegisterUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AccountsRegisterCreate(registerUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register new email.
         * @param {DefaultRegisterEmailRequest} defaultRegisterEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AccountsRegisterEmailCreate(defaultRegisterEmailRequest: DefaultRegisterEmailRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefaultRegisterEmail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AccountsRegisterEmailCreate(defaultRegisterEmailRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reset password, given the signature and timestamp from the link.
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AccountsResetPasswordCreate(resetPasswordRequest: ResetPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResetPassword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AccountsResetPasswordCreate(resetPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send email with reset password link.
         * @param {DefaultSendResetPasswordLinkRequest} defaultSendResetPasswordLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AccountsSendResetPasswordLinkCreate(defaultSendResetPasswordLinkRequest: DefaultSendResetPasswordLinkRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefaultSendResetPasswordLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AccountsSendResetPasswordLinkCreate(defaultSendResetPasswordLinkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verify email via signature.
         * @param {VerifyEmailRequest} verifyEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AccountsVerifyEmailCreate(verifyEmailRequest: VerifyEmailRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifyEmail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AccountsVerifyEmailCreate(verifyEmailRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verify registration via signature.
         * @param {VerifyRegistrationRequest} verifyRegistrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AccountsVerifyRegistrationCreate(verifyRegistrationRequest: VerifyRegistrationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifyRegistration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AccountsVerifyRegistrationCreate(verifyRegistrationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} source 
         * @param {boolean} shellLicenseCompliant 
         * @param {boolean} tosCompliant 
         * @param {LicenseEnum} license 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ExtensionsCreate(source: any, shellLicenseCompliant: boolean, tosCompliant: boolean, license: LicenseEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExtensionUpload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ExtensionsCreate(source, shellLicenseCompliant, tosCompliant, license, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<string>} [uuid] 
         * @param {0 | 1 | 2 | 3 | 4} [status] 
         * @param {boolean} [recommended] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ExtensionsList(uuid?: Array<string>, status?: 0 | 1 | 2 | 3 | 4, recommended?: boolean, ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedExtensionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ExtensionsList(uuid, status, recommended, ordering, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ExtensionsRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Extension>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ExtensionsRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} query 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {boolean} [recommended] 
         * @param {'asc' | 'desc'} [ordering] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ExtensionsSearchRetrieve(query: string, page?: number, pageSize?: number, recommended?: boolean, ordering?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Extension>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ExtensionsSearchRetrieve(query, page, pageSize, recommended, ordering, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ExtensionsUpdatesRequest} extensionsUpdatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ExtensionsUpdatesCreate(extensionsUpdatesRequest: ExtensionsUpdatesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Extension>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ExtensionsUpdatesCreate(extensionsUpdatesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} extensionUuid 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {'json' | 'zip'} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ExtensionsVersionsList(extensionUuid: string, page?: number, pageSize?: number, format?: 'json' | 'zip', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedExtensionVersionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ExtensionsVersionsList(extensionUuid, page, pageSize, format, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} extensionUuid 
         * @param {string} version 
         * @param {'json' | 'zip'} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ExtensionsVersionsRetrieve(extensionUuid: string, version: string, format?: 'json' | 'zip', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExtensionVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ExtensionsVersionsRetrieve(extensionUuid, version, format, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1HelloRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1HelloRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProfileRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProfileRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1Api - factory interface
 * @export
 */
export const V1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1ApiFp(configuration)
    return {
        /**
         * Change the user password.
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsChangePasswordCreate(changePasswordRequest: ChangePasswordRequest, options?: any): AxiosPromise<ChangePassword> {
            return localVarFp.v1AccountsChangePasswordCreate(changePasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Logs in the user via given login and password.
         * @param {DefaultLoginRequest} defaultLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsLoginCreate(defaultLoginRequest: DefaultLoginRequest, options?: any): AxiosPromise<DefaultLogin> {
            return localVarFp.v1AccountsLoginCreate(defaultLoginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Logs out the user. returns an error if the user is not authenticated.
         * @param {LogoutRequest} [logoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsLogoutCreate(logoutRequest?: LogoutRequest, options?: any): AxiosPromise<Logout> {
            return localVarFp.v1AccountsLogoutCreate(logoutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get or set user profile.
         * @param {DefaultUserProfileRequest} defaultUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsProfileCreate(defaultUserProfileRequest: DefaultUserProfileRequest, options?: any): AxiosPromise<DefaultUserProfile> {
            return localVarFp.v1AccountsProfileCreate(defaultUserProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get or set user profile.
         * @param {PatchedDefaultUserProfileRequest} [patchedDefaultUserProfileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsProfilePartialUpdate(patchedDefaultUserProfileRequest?: PatchedDefaultUserProfileRequest, options?: any): AxiosPromise<DefaultUserProfile> {
            return localVarFp.v1AccountsProfilePartialUpdate(patchedDefaultUserProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get or set user profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsProfileRetrieve(options?: any): AxiosPromise<DefaultUserProfile> {
            return localVarFp.v1AccountsProfileRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Get or set user profile.
         * @param {DefaultUserProfileRequest} defaultUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsProfileUpdate(defaultUserProfileRequest: DefaultUserProfileRequest, options?: any): AxiosPromise<DefaultUserProfile> {
            return localVarFp.v1AccountsProfileUpdate(defaultUserProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Register new user.
         * @param {RegisterUserRequest} registerUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsRegisterCreate(registerUserRequest: RegisterUserRequest, options?: any): AxiosPromise<RegisterUser> {
            return localVarFp.v1AccountsRegisterCreate(registerUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Register new email.
         * @param {DefaultRegisterEmailRequest} defaultRegisterEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsRegisterEmailCreate(defaultRegisterEmailRequest: DefaultRegisterEmailRequest, options?: any): AxiosPromise<DefaultRegisterEmail> {
            return localVarFp.v1AccountsRegisterEmailCreate(defaultRegisterEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset password, given the signature and timestamp from the link.
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsResetPasswordCreate(resetPasswordRequest: ResetPasswordRequest, options?: any): AxiosPromise<ResetPassword> {
            return localVarFp.v1AccountsResetPasswordCreate(resetPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Send email with reset password link.
         * @param {DefaultSendResetPasswordLinkRequest} defaultSendResetPasswordLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsSendResetPasswordLinkCreate(defaultSendResetPasswordLinkRequest: DefaultSendResetPasswordLinkRequest, options?: any): AxiosPromise<DefaultSendResetPasswordLink> {
            return localVarFp.v1AccountsSendResetPasswordLinkCreate(defaultSendResetPasswordLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify email via signature.
         * @param {VerifyEmailRequest} verifyEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsVerifyEmailCreate(verifyEmailRequest: VerifyEmailRequest, options?: any): AxiosPromise<VerifyEmail> {
            return localVarFp.v1AccountsVerifyEmailCreate(verifyEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify registration via signature.
         * @param {VerifyRegistrationRequest} verifyRegistrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AccountsVerifyRegistrationCreate(verifyRegistrationRequest: VerifyRegistrationRequest, options?: any): AxiosPromise<VerifyRegistration> {
            return localVarFp.v1AccountsVerifyRegistrationCreate(verifyRegistrationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} source 
         * @param {boolean} shellLicenseCompliant 
         * @param {boolean} tosCompliant 
         * @param {LicenseEnum} license 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExtensionsCreate(source: any, shellLicenseCompliant: boolean, tosCompliant: boolean, license: LicenseEnum, options?: any): AxiosPromise<ExtensionUpload> {
            return localVarFp.v1ExtensionsCreate(source, shellLicenseCompliant, tosCompliant, license, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<string>} [uuid] 
         * @param {0 | 1 | 2 | 3 | 4} [status] 
         * @param {boolean} [recommended] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExtensionsList(uuid?: Array<string>, status?: 0 | 1 | 2 | 3 | 4, recommended?: boolean, ordering?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedExtensionList> {
            return localVarFp.v1ExtensionsList(uuid, status, recommended, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExtensionsRetrieve(uuid: string, options?: any): AxiosPromise<Extension> {
            return localVarFp.v1ExtensionsRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} query 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {boolean} [recommended] 
         * @param {'asc' | 'desc'} [ordering] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExtensionsSearchRetrieve(query: string, page?: number, pageSize?: number, recommended?: boolean, ordering?: 'asc' | 'desc', options?: any): AxiosPromise<Extension> {
            return localVarFp.v1ExtensionsSearchRetrieve(query, page, pageSize, recommended, ordering, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ExtensionsUpdatesRequest} extensionsUpdatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExtensionsUpdatesCreate(extensionsUpdatesRequest: ExtensionsUpdatesRequest, options?: any): AxiosPromise<Extension> {
            return localVarFp.v1ExtensionsUpdatesCreate(extensionsUpdatesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} extensionUuid 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {'json' | 'zip'} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExtensionsVersionsList(extensionUuid: string, page?: number, pageSize?: number, format?: 'json' | 'zip', options?: any): AxiosPromise<PaginatedExtensionVersionList> {
            return localVarFp.v1ExtensionsVersionsList(extensionUuid, page, pageSize, format, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} extensionUuid 
         * @param {string} version 
         * @param {'json' | 'zip'} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExtensionsVersionsRetrieve(extensionUuid: string, version: string, format?: 'json' | 'zip', options?: any): AxiosPromise<ExtensionVersion> {
            return localVarFp.v1ExtensionsVersionsRetrieve(extensionUuid, version, format, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1HelloRetrieve(options?: any): AxiosPromise<void> {
            return localVarFp.v1HelloRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfileRetrieve(id: number, options?: any): AxiosPromise<UserProfile> {
            return localVarFp.v1ProfileRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for v1AccountsChangePasswordCreate operation in V1Api.
 * @export
 * @interface V1ApiV1AccountsChangePasswordCreateRequest
 */
export interface V1ApiV1AccountsChangePasswordCreateRequest {
    /**
     * 
     * @type {ChangePasswordRequest}
     * @memberof V1ApiV1AccountsChangePasswordCreate
     */
    readonly changePasswordRequest: ChangePasswordRequest
}

/**
 * Request parameters for v1AccountsLoginCreate operation in V1Api.
 * @export
 * @interface V1ApiV1AccountsLoginCreateRequest
 */
export interface V1ApiV1AccountsLoginCreateRequest {
    /**
     * 
     * @type {DefaultLoginRequest}
     * @memberof V1ApiV1AccountsLoginCreate
     */
    readonly defaultLoginRequest: DefaultLoginRequest
}

/**
 * Request parameters for v1AccountsLogoutCreate operation in V1Api.
 * @export
 * @interface V1ApiV1AccountsLogoutCreateRequest
 */
export interface V1ApiV1AccountsLogoutCreateRequest {
    /**
     * 
     * @type {LogoutRequest}
     * @memberof V1ApiV1AccountsLogoutCreate
     */
    readonly logoutRequest?: LogoutRequest
}

/**
 * Request parameters for v1AccountsProfileCreate operation in V1Api.
 * @export
 * @interface V1ApiV1AccountsProfileCreateRequest
 */
export interface V1ApiV1AccountsProfileCreateRequest {
    /**
     * 
     * @type {DefaultUserProfileRequest}
     * @memberof V1ApiV1AccountsProfileCreate
     */
    readonly defaultUserProfileRequest: DefaultUserProfileRequest
}

/**
 * Request parameters for v1AccountsProfilePartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1AccountsProfilePartialUpdateRequest
 */
export interface V1ApiV1AccountsProfilePartialUpdateRequest {
    /**
     * 
     * @type {PatchedDefaultUserProfileRequest}
     * @memberof V1ApiV1AccountsProfilePartialUpdate
     */
    readonly patchedDefaultUserProfileRequest?: PatchedDefaultUserProfileRequest
}

/**
 * Request parameters for v1AccountsProfileUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1AccountsProfileUpdateRequest
 */
export interface V1ApiV1AccountsProfileUpdateRequest {
    /**
     * 
     * @type {DefaultUserProfileRequest}
     * @memberof V1ApiV1AccountsProfileUpdate
     */
    readonly defaultUserProfileRequest: DefaultUserProfileRequest
}

/**
 * Request parameters for v1AccountsRegisterCreate operation in V1Api.
 * @export
 * @interface V1ApiV1AccountsRegisterCreateRequest
 */
export interface V1ApiV1AccountsRegisterCreateRequest {
    /**
     * 
     * @type {RegisterUserRequest}
     * @memberof V1ApiV1AccountsRegisterCreate
     */
    readonly registerUserRequest: RegisterUserRequest
}

/**
 * Request parameters for v1AccountsRegisterEmailCreate operation in V1Api.
 * @export
 * @interface V1ApiV1AccountsRegisterEmailCreateRequest
 */
export interface V1ApiV1AccountsRegisterEmailCreateRequest {
    /**
     * 
     * @type {DefaultRegisterEmailRequest}
     * @memberof V1ApiV1AccountsRegisterEmailCreate
     */
    readonly defaultRegisterEmailRequest: DefaultRegisterEmailRequest
}

/**
 * Request parameters for v1AccountsResetPasswordCreate operation in V1Api.
 * @export
 * @interface V1ApiV1AccountsResetPasswordCreateRequest
 */
export interface V1ApiV1AccountsResetPasswordCreateRequest {
    /**
     * 
     * @type {ResetPasswordRequest}
     * @memberof V1ApiV1AccountsResetPasswordCreate
     */
    readonly resetPasswordRequest: ResetPasswordRequest
}

/**
 * Request parameters for v1AccountsSendResetPasswordLinkCreate operation in V1Api.
 * @export
 * @interface V1ApiV1AccountsSendResetPasswordLinkCreateRequest
 */
export interface V1ApiV1AccountsSendResetPasswordLinkCreateRequest {
    /**
     * 
     * @type {DefaultSendResetPasswordLinkRequest}
     * @memberof V1ApiV1AccountsSendResetPasswordLinkCreate
     */
    readonly defaultSendResetPasswordLinkRequest: DefaultSendResetPasswordLinkRequest
}

/**
 * Request parameters for v1AccountsVerifyEmailCreate operation in V1Api.
 * @export
 * @interface V1ApiV1AccountsVerifyEmailCreateRequest
 */
export interface V1ApiV1AccountsVerifyEmailCreateRequest {
    /**
     * 
     * @type {VerifyEmailRequest}
     * @memberof V1ApiV1AccountsVerifyEmailCreate
     */
    readonly verifyEmailRequest: VerifyEmailRequest
}

/**
 * Request parameters for v1AccountsVerifyRegistrationCreate operation in V1Api.
 * @export
 * @interface V1ApiV1AccountsVerifyRegistrationCreateRequest
 */
export interface V1ApiV1AccountsVerifyRegistrationCreateRequest {
    /**
     * 
     * @type {VerifyRegistrationRequest}
     * @memberof V1ApiV1AccountsVerifyRegistrationCreate
     */
    readonly verifyRegistrationRequest: VerifyRegistrationRequest
}

/**
 * Request parameters for v1ExtensionsCreate operation in V1Api.
 * @export
 * @interface V1ApiV1ExtensionsCreateRequest
 */
export interface V1ApiV1ExtensionsCreateRequest {
    /**
     * 
     * @type {any}
     * @memberof V1ApiV1ExtensionsCreate
     */
    readonly source: any

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1ExtensionsCreate
     */
    readonly shellLicenseCompliant: boolean

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1ExtensionsCreate
     */
    readonly tosCompliant: boolean

    /**
     * 
     * @type {LicenseEnum}
     * @memberof V1ApiV1ExtensionsCreate
     */
    readonly license: LicenseEnum
}

/**
 * Request parameters for v1ExtensionsList operation in V1Api.
 * @export
 * @interface V1ApiV1ExtensionsListRequest
 */
export interface V1ApiV1ExtensionsListRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ApiV1ExtensionsList
     */
    readonly uuid?: Array<string>

    /**
     * 
     * @type {0 | 1 | 2 | 3 | 4}
     * @memberof V1ApiV1ExtensionsList
     */
    readonly status?: 0 | 1 | 2 | 3 | 4

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1ExtensionsList
     */
    readonly recommended?: boolean

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1ExtensionsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1ExtensionsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1ExtensionsList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v1ExtensionsRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1ExtensionsRetrieveRequest
 */
export interface V1ApiV1ExtensionsRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiV1ExtensionsRetrieve
     */
    readonly uuid: string
}

/**
 * Request parameters for v1ExtensionsSearchRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1ExtensionsSearchRetrieveRequest
 */
export interface V1ApiV1ExtensionsSearchRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiV1ExtensionsSearchRetrieve
     */
    readonly query: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ExtensionsSearchRetrieve
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ExtensionsSearchRetrieve
     */
    readonly pageSize?: number

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1ExtensionsSearchRetrieve
     */
    readonly recommended?: boolean

    /**
     * 
     * @type {'asc' | 'desc'}
     * @memberof V1ApiV1ExtensionsSearchRetrieve
     */
    readonly ordering?: 'asc' | 'desc'
}

/**
 * Request parameters for v1ExtensionsUpdatesCreate operation in V1Api.
 * @export
 * @interface V1ApiV1ExtensionsUpdatesCreateRequest
 */
export interface V1ApiV1ExtensionsUpdatesCreateRequest {
    /**
     * 
     * @type {ExtensionsUpdatesRequest}
     * @memberof V1ApiV1ExtensionsUpdatesCreate
     */
    readonly extensionsUpdatesRequest: ExtensionsUpdatesRequest
}

/**
 * Request parameters for v1ExtensionsVersionsList operation in V1Api.
 * @export
 * @interface V1ApiV1ExtensionsVersionsListRequest
 */
export interface V1ApiV1ExtensionsVersionsListRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiV1ExtensionsVersionsList
     */
    readonly extensionUuid: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1ExtensionsVersionsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1ExtensionsVersionsList
     */
    readonly pageSize?: number

    /**
     * 
     * @type {'json' | 'zip'}
     * @memberof V1ApiV1ExtensionsVersionsList
     */
    readonly format?: 'json' | 'zip'
}

/**
 * Request parameters for v1ExtensionsVersionsRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1ExtensionsVersionsRetrieveRequest
 */
export interface V1ApiV1ExtensionsVersionsRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiV1ExtensionsVersionsRetrieve
     */
    readonly extensionUuid: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiV1ExtensionsVersionsRetrieve
     */
    readonly version: string

    /**
     * 
     * @type {'json' | 'zip'}
     * @memberof V1ApiV1ExtensionsVersionsRetrieve
     */
    readonly format?: 'json' | 'zip'
}

/**
 * Request parameters for v1ProfileRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1ProfileRetrieveRequest
 */
export interface V1ApiV1ProfileRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ProfileRetrieve
     */
    readonly id: number
}

/**
 * V1Api - object-oriented interface
 * @export
 * @class V1Api
 * @extends {BaseAPI}
 */
export class V1Api extends BaseAPI {
    /**
     * Change the user password.
     * @param {V1ApiV1AccountsChangePasswordCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AccountsChangePasswordCreate(requestParameters: V1ApiV1AccountsChangePasswordCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AccountsChangePasswordCreate(requestParameters.changePasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logs in the user via given login and password.
     * @param {V1ApiV1AccountsLoginCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AccountsLoginCreate(requestParameters: V1ApiV1AccountsLoginCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AccountsLoginCreate(requestParameters.defaultLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logs out the user. returns an error if the user is not authenticated.
     * @param {V1ApiV1AccountsLogoutCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AccountsLogoutCreate(requestParameters: V1ApiV1AccountsLogoutCreateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AccountsLogoutCreate(requestParameters.logoutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get or set user profile.
     * @param {V1ApiV1AccountsProfileCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AccountsProfileCreate(requestParameters: V1ApiV1AccountsProfileCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AccountsProfileCreate(requestParameters.defaultUserProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get or set user profile.
     * @param {V1ApiV1AccountsProfilePartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AccountsProfilePartialUpdate(requestParameters: V1ApiV1AccountsProfilePartialUpdateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AccountsProfilePartialUpdate(requestParameters.patchedDefaultUserProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get or set user profile.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AccountsProfileRetrieve(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AccountsProfileRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get or set user profile.
     * @param {V1ApiV1AccountsProfileUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AccountsProfileUpdate(requestParameters: V1ApiV1AccountsProfileUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AccountsProfileUpdate(requestParameters.defaultUserProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register new user.
     * @param {V1ApiV1AccountsRegisterCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AccountsRegisterCreate(requestParameters: V1ApiV1AccountsRegisterCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AccountsRegisterCreate(requestParameters.registerUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register new email.
     * @param {V1ApiV1AccountsRegisterEmailCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AccountsRegisterEmailCreate(requestParameters: V1ApiV1AccountsRegisterEmailCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AccountsRegisterEmailCreate(requestParameters.defaultRegisterEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset password, given the signature and timestamp from the link.
     * @param {V1ApiV1AccountsResetPasswordCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AccountsResetPasswordCreate(requestParameters: V1ApiV1AccountsResetPasswordCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AccountsResetPasswordCreate(requestParameters.resetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send email with reset password link.
     * @param {V1ApiV1AccountsSendResetPasswordLinkCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AccountsSendResetPasswordLinkCreate(requestParameters: V1ApiV1AccountsSendResetPasswordLinkCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AccountsSendResetPasswordLinkCreate(requestParameters.defaultSendResetPasswordLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify email via signature.
     * @param {V1ApiV1AccountsVerifyEmailCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AccountsVerifyEmailCreate(requestParameters: V1ApiV1AccountsVerifyEmailCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AccountsVerifyEmailCreate(requestParameters.verifyEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify registration via signature.
     * @param {V1ApiV1AccountsVerifyRegistrationCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AccountsVerifyRegistrationCreate(requestParameters: V1ApiV1AccountsVerifyRegistrationCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AccountsVerifyRegistrationCreate(requestParameters.verifyRegistrationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1ExtensionsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ExtensionsCreate(requestParameters: V1ApiV1ExtensionsCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ExtensionsCreate(requestParameters.source, requestParameters.shellLicenseCompliant, requestParameters.tosCompliant, requestParameters.license, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1ExtensionsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ExtensionsList(requestParameters: V1ApiV1ExtensionsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ExtensionsList(requestParameters.uuid, requestParameters.status, requestParameters.recommended, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1ExtensionsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ExtensionsRetrieve(requestParameters: V1ApiV1ExtensionsRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ExtensionsRetrieve(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1ExtensionsSearchRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ExtensionsSearchRetrieve(requestParameters: V1ApiV1ExtensionsSearchRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ExtensionsSearchRetrieve(requestParameters.query, requestParameters.page, requestParameters.pageSize, requestParameters.recommended, requestParameters.ordering, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1ExtensionsUpdatesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ExtensionsUpdatesCreate(requestParameters: V1ApiV1ExtensionsUpdatesCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ExtensionsUpdatesCreate(requestParameters.extensionsUpdatesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1ExtensionsVersionsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ExtensionsVersionsList(requestParameters: V1ApiV1ExtensionsVersionsListRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ExtensionsVersionsList(requestParameters.extensionUuid, requestParameters.page, requestParameters.pageSize, requestParameters.format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1ExtensionsVersionsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ExtensionsVersionsRetrieve(requestParameters: V1ApiV1ExtensionsVersionsRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ExtensionsVersionsRetrieve(requestParameters.extensionUuid, requestParameters.version, requestParameters.format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1HelloRetrieve(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1HelloRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1ProfileRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ProfileRetrieve(requestParameters: V1ApiV1ProfileRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ProfileRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


